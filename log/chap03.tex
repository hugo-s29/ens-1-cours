\documentclass[./main]{subfiles}

\begin{document}
  \chapter{L'arithmétique de Peano.}
  \begin{itemize}
    \item \textsc{Dedekind} (1988) et \textsc{Peano} (1889) formalisent l'arithmétique.
    \item En 1900, David \textsc{Hilbert}, lors du 2ème ICM à Paris, donne un programme et dont le 2nd problème est la \textit{cohérence de l'arithmétique}.
    \item En 1901, \textsc{Russel} donne son paradoxe concernant l'"ensemble" de tous les ensembles.
    \item En 1930, \textsc(Hilbert) est toujours optimiste : "On doit savoir, on saura !"
  \end{itemize}

  La formalisation de l'arithmétique engendre deux questions :
  \begin{enumerate}
    \item est-ce que tout théorème est prouvable ? ($\triangleright$ complétude)
    \item existe-t-il un algorithme pour décider si un théorème est prouvable ? ($\triangleright$ décidabilité)
  \end{enumerate}

  Le second point est appelé "\textit{Entscheidungsproblem}", le problème de décision, en 1928.

  \begin{itemize}
    \item En 1931, Gödel répond \textsc{non} à ces deux questions.
  \end{itemize}

  On a donné plusieurs formalisations des algorithmes :
  \begin{itemize}
    \item en 1930, le $\lambda$-calcul de Church ;
    \item en 1931--34, les fonctions récursives de Herbrand et Gödel ;
    \item en 1936, les machines de Turing.
  \end{itemize}
  On démontre que les trois modèles sont équivalents.

  La thèse de Church--Turing nous convainc qu'il n'existe pas de modèle plus évolué "dans la vraie vie".

  \section{Les axiomes.}

  On définit le langage $\mathcal{L}_0 = \{\zero, \succ, \oplus, \otimes\}$ où
  \begin{itemize}
    \item $\zero$ est un symbole de constante ;
    \item $\succ$ est un symbole de fonction unaire ;
    \item $\oplus$ et $\otimes$ sont deux symboles de fonctions binaires.
  \end{itemize}

  On verra plus tard que l'on peut ajouter une relation binaire $\le$.

  \begin{rmk}[Convention]
    La structure $\mathds{N}$ représente la $\mathcal{L}_0$-structure dans laquelle on interprète les symboles de manière habituelle :
    \begin{itemize}
      \item pour $\zero$, c'est $0$ ;
      \item pour $\succ$, c'est $\lambda n.  n + 1$ (\textit{i.e.} $x \mapsto x + 1$) ;
      \item pour $\oplus$, c'est $\lambda n \: m.  n + m$ ;
      \item pour $\otimes$, c'est $\lambda n \: m.  n \times m$.
    \end{itemize}
  \end{rmk}

  \subsubsection{Les axiomes de Peano.}

  On se place dans le cas égalitaire.
  L'ensemble $\mathcal{P}$ est composé de $\mathcal{P}_0$ un ensemble fini d'axiomes (A1--A7) et d'un schéma d'induction (SI).

  Trois axiomes pour le successeur :
  \begin{description}
    \item[A1.] $\forall x \: \lnot (\succ x = \zero)$
    \item[A2.] $\forall x \: \exists y \: \big(\lnot (x = \zero) \to x = \succ y\big)$
    \item[A3.] $\forall x \: \forall y \: (\succ x = \succ y \to x = y)$
  \end{description}

  Deux axiomes pour l'addition :
  \begin{description}
    \item[A4.] $\forall x \: (x \oplus \zero = x)$ 
    \item[A5.] $\forall x \: \forall y \: (x \oplus (\succ y) = \succ(x \oplus y))$
  \end{description}

  Deux axiomes pour la multiplication :
  \begin{description}
    \item[A6.] $\forall x \: (x \otimes \zero = \zero)$
    \item[A7.] $\forall x \: \forall y \: \big(x \otimes (\succ y) = (x \otimes y) \oplus x\big)$
  \end{description}

  Et le schéma d'induction :
  \begin{description}
    \item[SI.]
      Pour toute formule $F$ de variables libres $x_0, \ldots, x_n$,
  \end{description}
  \fitbox{$\forall x_1 \: \cdots \: \forall x_n \: \Big(
    \big(F(\zero, \ldots, x_1, \ldots, x_n) \land \forall x \: (F(x, x_1, \ldots, x_n) \to F(\succ x, x_1, \ldots, x_n))\big)
    \to \forall x \: F(x, x_1, \ldots, x_n)
  \Big).$}

  \begin{rmk}
    \begin{itemize}
      \item Le schéma est le SI avec hypothèse faible, qui permet de montrer le SI avec hypothèse forte.
        On adopte la notation $\forall y \le x \: F(y, x_1, \ldots, x_n)$ pour \[
        \forall y \: \big( (\exists z \:  z \oplus y = x) \to  F(y, x_1, \ldots, x_n) \big)
        .\]
        Le SI avec hypothèse forte est :
    \end{itemize}
    \fitbox{
      $\forall x_1 \: \cdots \: \forall x_n \: \Big(
      \big(F(\zero, \ldots, x_1, \ldots, x_n) \land \forall x \: \big((\forall y \le  x \: F(y, x_1, \ldots, x_n)) \to F(\succ x, x_1, \ldots, x_n)\big)\big)
      \to \forall x \: F(x, x_1, \ldots, x_n)
      \Big)$
    }
    \begin{itemize}
      \item L'ensemble $\mathcal{P}$ est non-contradictoire car $\mathds{N}$ est un modèle, appelé \textit{modèle standard}.
      \item On peur remplacer le SI par une nouvelle règle de démonstration :
        \[
        \begin{prooftree}
          \hypo{\Gamma \vdash F(\zero)}
          \hypo{\Gamma \vdash \forall y\: \big(F(y) \to F(\succ y)\big)}
          \infer 2[\mathsf{rec}]{\Gamma \vdash \forall x \: F(x)}
        \end{prooftree}
        .\]
    \end{itemize}
  \end{rmk}

  \begin{exo}
    Montrer l'équivalence entre SI et la nouvelle règle $\mathsf{rec}$, \textit{i.e.} on peut démontrer les mêmes théorèmes.
  \end{exo}

  \begin{nota}
    On note $\repr{n}$ le terme  $\underbrace{\succ \cdots  \succ}_{n \text{ fois}}  \zero$ pour $n \in \mathds{N}$.
  \end{nota}

  \begin{defn}
    Dans une $\mathcal{L}_0$-structure, on dit qu'un élément est \textit{standard} s'il est l'interprétation d'un terme $\repr{n}$ avec  $n \in \mathds{N}$.
  \end{defn}

  \begin{rmk}
    Dans $\mathds{N}$ (le modèle standard), tout élément est standard.
  \end{rmk}

  \begin{thm}
    Il existe des modèles de $\mathcal{P}$ non isomorphes à $\mathds{N}$.
  \end{thm}
  \begin{prv}
    \begin{enumerate}
      \item Avec le théorème de Löwenheim-Skolem, il existe un modèle de $\mathcal{P}$ de cardinal $\kappa$ pour tout $\kappa \ge \aleph_0$, et $\operatorname{card} \mathds{N} = \aleph_0$.
      \item Autre preuve, on considère un symbole de constante $c$ et on pose $\mathcal{L} := \mathcal{L}_0 \cup \{c\}$.
        On considère la théorie \[
          T := \mathcal{P} \cup \mleft\{\,\lnot(c = \repr{n}) \;\middle|\; n \in \mathds{N}\,\mright\}
        .\]
        Montrons que $T$ a un modèle.
        Par le théorème de compacité de la logique du premier ordre, il suffit de montrer que $T$ est finiment satisfiable.
        Soit $T' \subseteq_\mathrm{fini} T$ : par exemple, 
        \[
          T' \subseteq \mathcal{P} \cup \{\lnot(c = \repr{n_1}), \lnot (c = \repr{n_2}), \ldots, (c = \repr{n_k})\} 
        ,\] 
        et $n_k \ge n_1, \ldots, n_{k-1}$.
        On construit un modèle de $T'$ correspondant à $\mathds{N}$ où $c$ est interprété par $n_k + 1$.
        Ainsi, $T'$ est satisfiable et donc $T$ aussi avec un modèle $\mathcal{M}$.

        Montrons que $\mathds{N}$ et $\mathcal{M}$ ne sont pas isomorphes.
        Par l'absurde, supposons que $\varphi : \mathcal{M} \to \mathds{N}$ soit un isomorphisme.
        Alors $\gamma := \varphi(c_{\mathcal{M}})$ satisfait les mêmes formules que $c_{\mathcal{M}}$, par exemple, pour tout $n \in \mathds{N}$, $\mathcal{M} \models \lnot (c = \repr{n})$.
        Or, on ne peut pas avoir $\mathds{N} \models \lnot (\repr{\gamma} = \repr{n})$ pour tout $n \in \mathds{N}$.
        \textbf{\textit{Absurde.}}
    \end{enumerate}
  \end{prv}

  On a montré que tous les modèles isomorphes à $\mathds{N}$ n'ont que des éléments standards.

  \begin{thm}
    Dans tout modèle $\mathcal{M}$ de $\mathcal{P}$, 
    \begin{enumerate}
      \item l'addition est commutative et associative ;
      \item la multiplication aussi ;
      \item la multiplication est distributive par rapport à l'addition ;
      \item tout élément est \textit{régulier} pour l'addition :
        \[
        \mathcal{M} \models \forall x \: \forall y \: \forall z \: (x \oplus y = x \oplus z \to y = z) \;
        ;\]
      \item tout élément non nul est régulier pour la multiplication : 
        \[
        \mathcal{M} \models \forall x\: \forall y \: \forall z \: ((\lnot (x = \zero) \land x \otimes y = x \otimes z) \to y = z)
        \;;\]
      \item la formule suivante définie un ordre total sur $\mathcal{M}$ compatible avec $+$ et $\times$ :
        \[
        x \le y \text{ ssi } \exists z \: (x \oplus z = y)
        .\]
    \end{enumerate}
  \end{thm}
  \begin{prv}
    On prouve la commutativité de $+$ en trois étapes.
    \begin{enumerate}
      \item On montre  $\mathcal{P} \vdash \forall x \: (\zero \oplus x = x)$.
        On utilise le SI avec la formule $F(x) := (\zero \oplus x = x)$.
        \begin{itemize}
          \item On a $\mathcal{P} \vdash \zero \oplus \zero = \zero$ par A4.
          \item On montre $\mathcal{P} \vdash \forall x \: F(x) \to F(\succ x)$, c'est à dire :
            \[
            \forall x \: \big((\zero \oplus x = x) \to (\zero \oplus (\succ x) = \succ x) \big)
            .\]
            On peut le montrer par A5.
        \end{itemize}

        \textbf{Questions/Remarques :}
        \begin{itemize}
          \item Pourquoi pas une récurrence normale ?
            On n'est pas forcément dans $\mathds{N}$ !
          \item Grâce au théorème de complétude, on peut raisonner sur les modèles, donc en maths naïves.
        \end{itemize}
      \item On montre $\mathcal{P} \vdash \forall x \: \forall y \: \succ(x \oplus y) = (\succ x) \oplus y$.
        On veut utiliser le schéma d'induction avec $F(x, y) := \succ(x \oplus y) = (\succ x) \oplus y$.
        Mais ça ne marche pas\ldots (Pourquoi ?)

        La bonne formule est $F(y, x) := \succ(x \oplus y) = (\succ x) \oplus y$.
        \begin{itemize}
          \item On montre $\mathcal{P} \vdash F(\zero, x)$, c'est à dire 
            \[
            \mathcal{P} \vdash \succ(x \oplus \zero) = (\succ x) \oplus \zero.
            \]
            Ceci est vrai car 
            \[
            \succ(x \oplus \zero) \underset {\text{A4}} = \succ x \underset {\text{A4}} = (\succ x) \oplus \zero
            .\]
          \item On a $\mathcal{P} \vdash F(y, x) \to F(\succ y, x)$ car : si $\succ(x \oplus y) = (\succ x) \oplus y$, alors 
        \end{itemize}
        \[
        \succ(x \oplus (\succ y)) \underset {\text{A5}} = \succ \succ (x \oplus y) \underset{\text{hyp}} = \succ((\succ x) \oplus y) \underset {\text{A5}} (\succ x) = \oplus (\succ y)
        .\]
      \item On utilise le SI avec $F(x, y) := (x \oplus y = y \oplus x)$.
        D'une part, on a $F(\zero, y) = (\zero \oplus y = y \oplus \zero)$ par 1 et A4.
        D'autre part, si l'on a $x \oplus y = y \oplus x$ alors  $(\succ x) \oplus y = y \oplus (\succ x)$ par A5 et 2.
        Par le SI, on conclut.
    \end{enumerate}
  \end{prv}

  \begin{exo}
    Finir la preuve du théorème.
  \end{exo}

  \section{Liens entre $\mathds{N}$ et un modèle $\mathcal{M}$ de $\mathcal{P}$.}

  \begin{defn}
     Si $\mathcal{M} \models \mathcal{P}_0$ et $\mathcal{N} \models \mathcal{P}_0$ et $\mathcal{N}$ une sous-interprétation de $\mathcal{M}$, on dit que $\mathcal{N}$ est un segment initial de $\mathcal{M}$, ou que $\mathcal{M}$ est une extension finale de $\mathcal{N}$, si pour tous $a,b,c \in |\mathcal{M}|$ avec $a \in |\mathcal{N}|$ on a :
    \begin{enumerate}
      \item si $\mathcal{M} \models c \le a$ alors $c \in |\mathcal{N}|$ ;
      \item si $b \not\in |\mathcal{N}|$ alors $\mathcal{M} \models a \le b$.
    \end{enumerate}
  \end{defn}

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}
      \filldraw[draw=deepblue,fill=NavyBlue!5] (0, 0) rectangle (5, 1.5);
      \node[deepblue] at (4.6, 1.2) {$\mathcal{M}$};
      \filldraw[draw=deepgreen,fill=ForestGreen!5] (0.1, 0.1) rectangle (2.5, 1.4);
      \node[deepgreen] at (0.5, 1.10) {$\mathcal{N}$};
      \node[fill,deepblue,circle,inner sep=1pt] (C) at (1, 0.35) {};
      \node[deepblue] at (1.5, 0.35) {$\le$};
      \node[deepblue] at (2.5, 0.35) {$\le$};
      \node[fill,deepblue,circle,inner sep=1pt] (A) at (2, 0.35) {};
      \node[fill,deepblue,circle,inner sep=1pt] (B) at (3, 0.35) {};
      \node[deepblue,above=3pt of A] {$a$};
      \node[deepblue,above=3pt of B] {$b$};
      \node[deepblue,above=3pt of C] {$c$};
    \end{tikzpicture}
  \end{figure}

  \begin{rmk}
    \begin{itemize}
      \item Les points peuvent être incomparables et dans $\mathcal{M}$.
      \item L'ensemble $\mathcal{P}_0$ est très faible, on ne montre même pas que $\oplus$ commute ou que $\le$ est une relation d'ordre (\textit{c.f.} TD).
    \end{itemize}
  \end{rmk}

  \begin{thm}
    Soit $\mathcal{M} \models \mathcal{P}_0$.
    Alors, le sous-ensemble de $\mathcal{M}$ suivant est une sous-interprétation de $\mathcal{M}$ qui est un segment initial et qui est isomorphe à $\mathds{N}$ :
    \[
    \mleft\{\,a \in |\mathcal{M}| \;\middle|\;
    \begin{array}{l}
      \text{il existe $n \in \mathds{N}$ et $a$}\\
      \text{est l'interprétation}\\
      \text{de $\repr{n}$ dans $\mathcal{M}$}
    \end{array}\,\mright\} 
    .\]
  \end{thm}

  \begin{prv}[Idée de la preuve]
    \begin{enumerate}
      \item Pour tout $n \in \mathds{N}$, on a $\mathcal{P}_0 \vdash \repr{n+1} = \succ \repr{n}$.
      \item Pour tout $n, m \in \mathds{N}$, on a $\mathcal{P}_0 \vdash \repr{m} \oplus \repr{n} = \repr{m+n}$.
      \item Pour tout $n, m \in \mathds{N}$, on a $\mathcal{P}_0 \vdash \repr{m} \otimes \repr{n} = \repr{m \times n}$.
      \item Pour tout $n \in \mathds{N}_\star$, on a $\mathcal{P}_0 \vdash \lnot (\repr{n} = \zero)$.
      \item Pour tout $n  \neq m$, on a $\mathcal{P}_0 \vdash \lnot (\repr{m} = \repr{n})$.
      \item Pour tout $n \in \mathds{N}$ (admis), on a 
        \[
          \mathcal{P}_0 \vdash \forall x \: \big(x \le \repr{n} \to (x = \zero \lor x = \repr{1} \lor \cdots \lor x = \repr{n}) \big)
        .\] 
      \item Pour tout $x$, on a $\mathcal{P}_0 \vdash \forall x \: (x \le  \repr{n} \lor \repr{n} \le x)$.
    \end{enumerate}
  \end{prv}

  \section{Les fonctions représentables.}

  Cette section détaille un outil technique pour montrer le théorème d'incomplétude de Gödel vu plus tard.
  On code tout avec des entiers !

  \begin{defn}
    Soit $f : \mathds{N}^p \to \mathds{N}$ une fonction totale et $F(x_0, \ldots, x_p)$ une formule de $\mathcal{L}_0$.
    On dit que $F$ \textit{représente} $f$ si, pour tout $p$-uplet d'entiers $(n_1, \ldots, n_p)$ on a : \[
      \mathcal{P}_0 \vdash \forall y \: \big(F(y, \repr{n_1}, \ldots, \repr{n_p}) \leftrightarrow y = \repr{f(n_1, \ldots, n_p)}\big)
    .\]
    On dit que $f$ est \textit{représentable} s'il existe une formule qui la représente.

    Un ensemble de $p$-uplets $A \subseteq \mathds{N}^p$ est \textit{représenté} par $F(x_1, \ldots, x_p)$ si pour tout $p$-uplet d'entiers $(n_1, \ldots, n_p)$, on a 
    \begin{enumerate}
      \item si $(n_1, \ldots, n_p) \in A$ alors $\mathcal{P}_0 \vdash F(n_1, \ldots, n_p)$ ;
      \item si $(n_1, \ldots, n_p) \not\in A$ alors $\mathcal{P}_0 \vdash \lnot F(n_1, \ldots, n_p)$.
    \end{enumerate}
    On dit que $A$ est \textit{représentable} s'il existe une formule qui le représente.
  \end{defn}

  \begin{exo}
    Montrer qu'un ensemble est représentable ssi sa fonction indicatrice l'est.
  \end{exo}

  \begin{exm}[Les briques de base des fonctions récursives]~\\[-\baselineskip]
    \begin{itemize}
      \item La fonction nulle $f : \mathds{N}\to \mathds{N}, x \mapsto 0$ est représentable par $F(x_0, x_1) := x_0 = \zero$.
      \item Les fonctions constantes $f : \mathds{N}\to \mathds{N}, x \mapsto n$ sont représentables par $F(x_0, x_1) := x_0 = \repr{n}$, où $n \in \mathds{N}$.
      \item Les projections $\pi^i_p : \mathds{N}^p \to \mathds{N}, (x_1, \ldots, x_p) \mapsto x_i$ sont représentables par $F(x_0, x_1, \ldots, x_p) := x_0 = x_i$.
      \item La fonction successeur $f : \mathds{N}\to \mathds{N}, x \mapsto x + 1$ est représentable par $F(x_0, x_1) := x_0 = (\succ x_1)$.
      \item L'addition $f : \mathds{N}^2 \to \mathds{N}, (x,y) \mapsto x+y$ est représentable par $F(x_0, x_1, x_2) := x_0 = x_1 \oplus x_2$.
      \item La multiplication $f : \mathds{N}^2 \to \mathds{N}, (x,y) \mapsto x\times y$ est représentable par $F(x_0, x_1, x_2) := x_0 = x_1 \otimes x_2$.
    \end{itemize}
  \end{exm}

  On introduit trois nouvelles opérations.
  \begin{description}
    \item[Récurrence.]
      Soient $g(x_1, \ldots, x_p)$ et $h(x_1, \ldots, x_{p+2})$ des fonctions partielles.
      On définit la fonction partielle $f$ par :
      \begin{itemize}
        \item $f(0, x_1, \ldots, x_p) := g(x_1, \ldots, x_p)$ ;
        \item $f(x_0 + 1, x_1, \ldots, x_p) := h(x_0, f(x_0, \ldots, x_p), x_1, \ldots, x_p)$.
      \end{itemize}
    \item[Composition.]
      Soient $f_1, \ldots, f_n$ des fonctions partielles de $p$ variables et $g$ une fonction partielle de $n$ variables.
      Alors, la fonction composée $g(f_1, \ldots, f_n)$ est définie en $(x_1, \ldots, x_p)$ ssi les fonctions $f_i$ le sont et $g$ est définie en $\big( f_1(x_1, \ldots, x_p), \ldots, f_n(x_1, \ldots, x_p)\big)$.
    \item[Schéma $\mu$.]
      Soit $f(x_1, \ldots x_{p+1})$ une fonction partielle.
      Soit \[
        g(x_1, \ldots, x_p) := \mu y.\: (f(x_1, \ldots, x_p, y) = 0)
      .\]
      Elle est définie en $(x_1, \ldots, x_p)$ si et seulement s'il existe $y$ tel que $f(x_1, \ldots, x_p, y) = 0$ et tous les $f(x_1, \ldots, x_p, x)$ sont définies pour $x \le y$.
      Dans ce cas, $g(x_1, \ldots, x_p)$ est le plus petit $y$ tel que $f(x_1, \ldots, x_p, y) = 0$.
  \end{description}

  \begin{defn}
    L'ensemble des fonctions récursives primitives (\textit{resp.} récursives) est le plus petit ensemble des fonctions contenant les briques de base et stable par composition  et récurrence (\textit{resp.} par composition, récurrence et schéma $\mu$).
  \end{defn}

  \begin{exm}
    Les fonctions \[
    f(x_1, x_2, y) := y^2 - (x_1+x_2) y + x_1 x_2
    \]et\[
    f(x_1, x_2) := \min(x_1, x_2)
    \] sont récursives primitives.
  \end{exm}

  \begin{defn}
    Une fonction récursive \textit{totale} est une fonction récursive définie partout.
  \end{defn}

  \begin{rmk}
    \begin{itemize}
      \item Une fonction récursive primitive est totale.
      \item Une fonction récursive primitive peut se fabriquer avec un seul schéma $\mu$ à la fin (\textit{c.f.} cours de FDI).
      \item \textit{Rappel}.
        Une fonction $f : \mathds{N}^p \to \mathds{N}$ totale est représentée par la formule $F(x_0, \ldots, x_p)$ de $\mathcal{L}_0$ su pour tout $p$-uplet d'entiers $(n_1, \ldots, n_p)$ on a :
        \[
        \mathcal{P}_0 \vdash \forall y \: \big( F(y, \repr {n_1}, \ldots, \repr{n_p}) \leftrightarrow y = \repr{f(n_1, \ldots, n_p)} \big)
        .\] 
      \item \textit{Rappel}.
        Si $\mathcal{M} \models \mathcal{P}_0$ alors l'ensemble de $|\mathcal{M}|$ constitué de l'interprétation des termes standards est une sous-interprétation de $\mathcal{M}$ qui en est un segment initial et qui est isomorphe à $\mathds{N}$.
      \item \textit{Rappel}.
        Une sous-interprétation $\mathcal{N}$ est un segment initial de~$\mathcal{M}$ si 
        \begin{itemize}
          \item $a \in \mathcal{N}$ et $b \in \mathcal{M} \setminus \mathcal{N}$ alors $b \ge a$ ;
          \item $a \in \mathcal{N}$ et $c \le a$ alors $c \in \mathcal{N}$.
        \end{itemize}
    \end{itemize}
  \end{rmk}

  \begin{figure}[H]
    \centering
    \begin{tikzpicture}
      \filldraw[draw=deepblue,fill=NavyBlue!5] (0, 0) rectangle (5, 1.5);
      \node[deepblue] at (4.6, 1.2) {$\mathcal{M}$};
      \filldraw[draw=deepgreen,fill=ForestGreen!5] (0.1, 0.1) rectangle (2.5, 1.4);
      \node[deepgreen] at (0.5, 1.10) {$\mathcal{N}$};
      \node[fill,deepblue,circle,inner sep=1pt] (C) at (1, 0.35) {};
      \node[deepblue] at (1.5, 0.35) {$\le$};
      \node[deepblue] at (2.5, 0.35) {$\le$};
      \node[fill,deepblue,circle,inner sep=1pt] (A) at (2, 0.35) {};
      \node[fill,deepblue,circle,inner sep=1pt] (B) at (3, 0.35) {};
      \node[deepblue,above=3pt of A] {$a$};
      \node[deepblue,above=3pt of B] {$b$};
      \node[deepblue,above=3pt of C] {$c$};
    \end{tikzpicture}
  \end{figure}

  \begin{thm}
    Toute fonction récursive totale est représentable.
    \label{thm:rec-repr}
  \end{thm}
  On a déjà montré que les briques de base sont représentables.
  On montre trois lemmes qui montreront le théorème ci-dessus.

  \begin{lem}
    L'ensemble des fonctions représentables est clos par composition.
  \end{lem}
  \begin{prv}
    Soient $f_1(x_1, \ldots, x_p), \ldots, f_n(x_1, \ldots, x_p)$ et $g(x_1, \ldots, x_n)$ des fonctions représentées par $F_1(x_0, \ldots, x_p), \ldots, F_n(x_0, \ldots, x_p)$ et $G(x_0, \ldots, G_n)$.
    On va montrer que $h = g(f_1, \ldots, f_n)$ est représentée par 
    \[
    H(x_0, \ldots, x_o) := \exists y_0\: \cdots \: \exists y_n \: \big(
      G(x_0, y_1, \ldots, y_n) \land \bigwedge_{1 \le i \le  n} F_i(y_i, x_1, \ldots, x_p)
    \big)
    .\]
    En effet, pour tous entiers $n_1, \ldots, n_{\max(p, n)}$ :
    \begin{itemize}
      \item $\mathcal{P}_0 \vdash \forall y \: F_i(y_1, \repr{n_1}, \ldots, \repr{n_p}) \leftrightarrow y = \repr{f_i(n_1, \ldots, n_p)}$ ;
      \item $\mathcal{P}_0 \vdash \forall y \: G(y_1, \repr{n_1}, \ldots, \repr{n_n}) \leftrightarrow y = \repr{g(n_1, \ldots, n_n)}$.
    \end{itemize}
    Dans tout modèle $\mathcal{M}$ de $\mathcal{P}_0$, pour tout $y \in |\mathcal{M}|$, et tous $n_1, \ldots, n_p \in \mathds{N}$ on a $H(y, n_1, \ldots, n_p)$ est vraie ssi il existe $y_1, \ldots, y_n$ dans $|\mathcal{M}|$ et pour tout $i$, $F_i(y_i, x_1, \ldots, x_p)$ est vrai et $G(y, y_1, \ldots, y_n)$.
    Donc, par les hypothèses précédents, on a $H(y, n_1, \ldots, n_p)$ ssi il existe $y_1, \ldots, y_n$ dans $|\mathcal{M}|$ et pour tout $i$, $y_i = f_i(n_1, \ldots, n_p)$ et $y = g(y_1, \ldots, y_p)$, ssi \[
    y = g(f_1(n_1, \ldots, n_p), \ldots, f_n(n_1, \ldots, n_p))
    \]  ssi $y = h(n_1,\ldots,n_p)$.
    On conclut \[
      \mathcal{P}_0 \vdash \forall y\: \big(H(y, \repr{n_1}, \ldots, \repr{n_p}) \leftrightarrow y = \repr{h(n_1, \ldots, n_p)}\big)
    .\]
  \end{prv}

  \begin{lem}
    Si, à partir d'une fonction représentable totale, on obtient par schéma $\mu$ une fonction totale, alors cette fonction est représentable.
  \end{lem}
  \begin{prv}
    Soit $g : \mathds{N}^{p+1} \to \mathds{N}$ une fonction représentable totale, et soit $f : \mathds{N}^p \to \mathds{N}$ définie par \[
      f(x_1, \ldots, x_p) := \mu x_0.\:\big( g(x_0, \ldots, x_p) = 0 \big)
    .\]
    Montrons que si $f$ est totale alors elle est représentable.
    Soit $G (y, x_0, \ldots, x_p)$ qui représente $g$.
    Alors, pour tous $n_1, \ldots, n_p$ on a 
    \[
      \mathcal{P}_0 \vdash \forall y \: G(y, \repr{n_1}, \ldots, \repr{n_p}) \leftrightarrow y = \repr{g(n_1, \ldots, n_p)}
    .\]
    Considérons la formule \[
    F(y, n_1, \ldots, n_p) := G(0, y, x_1, \ldots, x_p)  \land \forall z < y, \lnot G(0, z, x_1, \ldots, x_p)
    ,\]
    où l'on note $\forall z < y \: H$ pour  $\forall z \: (\exists u \: \lnot (h = \repr{0}) \land z \oplus h = y) \to H$.
    Montrons que $F$ représente $f$.
    Soit $\mathcal{M}$ un modèle de $\mathcal{P}_0$.
    Soient $ n_1, \ldots, n_p$ des entiers et $y \in |\mathcal{M}|$.
    On a $F(y, n_1, \ldots, n_p)$ vrai ssi $G(0, y, n_1, \ldots, n_p)$ vrai et, pour tout $z < y$, $\lnot G(0, z, n_1, \ldots, n_p)$ est vrai.
    Montrons que $b := f(n_1, \ldots, n_p)$ est le seul élément à satisfaire $F(y, n_1, \ldots, n_p)$.
    On a bien $G(0, b, n_1, \ldots, n_p)$ par définition de $f$ et pour tout entier $z < b$, on a  $\lnot G(0, z, n_1, \ldots, n_p)$.
    Mais, si on a $z < b$ et  $z$ n'est pas un entier ?
    Ce cas n'existe pas car la sous-représentation isomorphe à $\mathds{N}$ est un segment initial, il n'y a donc que des entiers qui sont inférieurs à $b$ dans $|\mathcal{M}|$.
    Ainsi, $F(b, n_1, \ldots, n_p)$.
    Montrons que $b$ est le seul.
    Soit $y$ tel que $F(y, n_1, \ldots, n_p)$. Montrons que $y = b$.
    \begin{itemize}
      \item Si $y$ est un entier, c'est vrai par définition de $b$.
      \item Si $y$ n'est pas un entier, alors $y > b$.
        Donc, $g(y, x_1, \ldots, x_p) = 0$ et  $b < y$ avec  $g(b, x_1, \ldots, x_p) = 0$.
        Ainsi, $\forall  z < y \: \lnot G(0, z, x_1, \ldots, x_p)$ est fausse, et donc $F(y, n_1, \ldots, n_p)$ est fausse.
    \end{itemize}
 \end{prv}

 \begin{lem}
   L'ensemble des fonctions totales est stable par définition par récurrence.
   \label{lem:repr-rec}
 \end{lem}
 \begin{prv}
   Soient $f, g, h$ telles que 
    \begin{itemize}
     \item $f(0, x_1, \ldots, x_p) = g(x_1, \ldots, x_p)$
     \item $f(x_0 + 1, x_1, \ldots, x_p) = h(x_0, f(x_0, \ldots, x_p), x_1, \ldots, x_p)$
   \end{itemize}
   Soient $G, H$ représentant $g$ et $h$.
   On a dans $\mathds{N}$ : $y = f(x_0, \ldots, x_p)$ ssi il existe $z_0, \ldots, z_{x_0}$ tel que 
   \begin{itemize}
     \item $z_0 = g(x_1, \ldots, x_p)$
     \item $z_1 = h(0, z_0, x_1, \ldots, x_p)$
     \item $z_2 = h(1, z_1, x_1, \ldots, x_p)$
     \item $\vdots$ 
     \item $z_{x_0} = h(x_0-1, z_{x_0 - 1}, x_1, \ldots, x_p)$
     \item $y = z_{x_0}$
   \end{itemize}
   Zut ! On ne peut pas écrire $\exists z_0 \: \cdots \: \exists z_{x_0}$ !
   On va utiliser une fonction qui permet de coder une suite d'entiers dans un couple d'entier $(a,b)$.
   Interruption de la preuve. 
 \end{prv}

 \begin{lem}[Fonction $\beta$ de Gödel]
   Il existe une fonction $\beta$ à trois variables, récursive primitive et représentable, tel que pour tout  $p \in \mathds{N}$ et toute suite $(n_0, \ldots, n_p) \in \mathds{N}^{p+1}$, il existe des entiers $a$ et $b$ tels que pour tout $0 \le i \le p$, on ait $\beta(i, a, b) = n_i$.
 \end{lem}
 \begin{prv}
   Soient $(a_0, \ldots, a_p)$ une suite d'entiers deux à deux premiers, et $(n_0, \ldots, n_p)$ une suite d'entiers.
   Alors il existe $b \in \mathds{N}$ tel que, pour tout $0 \le i \le p$, $b \equiv n_i \pmod{a_i}$ (par le théorème Chinois).

   Choisissons $a$ et les $a_i$ (qui induisent $b$) ?
   On pose $a = m!$.
   Alors, on pose $a_i := a (i+1) + 1$ pour tout $0 \le i \le p$.
   Les $a_i$ sont bien deux à deux premiers.
   En effet, pour $j > i$, si  $c  \mid a_i$ et $c  \mid a_j$ avec $c$ premier, alors $c  \mid (a_i - a_j)$ donc $c  \mid a (j-i)$ et donc $c \le m$, donc $c  \mid m$.
   Ainsi, il existe bien $b$ tel que $b \equiv n_i \pmod {a_i}$.
   On définit ainsi  $\beta(i, a, b)$ comme le reste de la division de  $b$ par $a(i+1) + 1$.
   La fonction $\beta$ est représentée par  \[
   B(x_0, i, a, b) := \exists x_4 \: b = x_4 \otimes \succ (a \otimes (\succ i)) \land x_4 < \succ(x \otimes \succ i)
   .\]
   On considère $B'(x_0, x_1, x_2, x_3) := B(x_0, x_1, x_2, x_3) \land \forall x_4 < x_0 \:\lnot B(x_4, x_1, x_2, x_3)$.
   Cette dernière formule représente aussi $\beta$ mais aussi que $x_0$ sera un entier standard.
 \end{prv}


 \vspace{1cm}
 \begin{prv}[On reprend la preuve du lemme~\ref{lem:repr-rec}]
   Soient $f, g, h$ telles que 
    \begin{itemize}
     \item $f(0, x_1, \ldots, x_p) = g(x_1, \ldots, x_p)$
     \item $f(x_0 + 1, x_1, \ldots, x_p) = h(x_0, f(x_0, \ldots, x_p), x_1, \ldots, x_p)$
   \end{itemize}
   Soient $G, H$ représentant $g$ et $h$.
   On a dans $\mathds{N}$ : $y = f(x_0, \ldots, x_p)$ ssi il existe $z_0, \ldots, z_{x_0}$ tel que 
   \begin{itemize}
     \item $z_0 = g(x_1, \ldots, x_p)$
     \item $z_1 = h(0, z_0, x_1, \ldots, x_p)$
     \item $z_2 = h(1, z_1, x_1, \ldots, x_p)$
     \item $\vdots$ 
     \item $z_{x_0} = h(x_0-1, z_{x_0 - 1}, x_1, \ldots, x_p)$
     \item $y = z_{x_0}$
   \end{itemize}
   ssi
   \begin{align*}
     \exists a \: \exists b \: \big[ &\\
    & (\exists z_0 \: B'(z_0, \repr{0}, a, b) \land G(z_0, x_1, \ldots, x_p)) \\
       {}\land & \forall i < x_0 \: \exists z \: \exists z' \: \begin{pmatrix}
      &B'(z, i, a, b)\\
      \land &B'(z', \succ i, a, b)\\
      \land &H(z', i, z, x_1, \ldots, x_p)
    \end{pmatrix} \\
      {}\land & B'(y, x_0, a, b)\\
              & \hspace{-1cm}\big]
   \end{align*}
   est vraie.
   Montrons que $F$ représente $f$.

   Soit $\mathcal{M} \models \mathcal{P}_0$, et $n_0, \ldots, n_p$ des entiers et $c \in |\mathcal{M}|$.
   \begin{itemize}
     \item Si $c$ interprète $\repr{f(n_0, \ldots, n_p)}$ alors en choisissant $a$ et $b$ avec le lemme précédent sur la fonction $\beta$, on a bien  $F(c, n_0, \ldots, n_p)$.
     \item Réciproquement, si $\mathcal{M} \models F(d, \repr{n_0}, \ldots, \repr{n_p})$ alors il existe $a, b, z_0$ tels que  $B'(z_0, \repr{0}, a, b)$ et  $G(z_0, n_1, \ldots, n_p)$, et donc $z_0 = g(n_1, \ldots, n_p)$.
       Et, pour tout $i \le  n_0$, il existe $r_i$ et  $s_i$ tels que  \[
       B'(r_i, i, a, b) \land B'(s_i, i + 1, a , b) \land H(s_i, i, r_i, n_1, \ldots, n_p)
       \] 
       donc $r_i = f(i, n_1, \ldots, n_p)$ grâce aux propriétés de $B'$ et car $r_i$ est un entier naturel, et donc par récurrence $d = f(n_0, \ldots, n_p)$.
   \end{itemize}
 \end{prv}

 Ceci conclut la preuve du théorème~\ref{thm:rec-repr}.

 Maintenant que l'on a transformé les fonctions en formules, on va faire l'opposé.
 Notre but est de montrer le théorème suivant :
 soit $T$ une théorie consistante contenant $\mathcal{P}_0$ alors $T$ est indécidable.
 La "partie technique" de l'indécidabilité de Gödel est la preuve par diagonalisation.

 \section{Indécidabilité des théories consistantes contenant $\mathcal{P}_0$.}

 On va coder :
 \begin{enumerate}
   \item les suites d'entiers ;
   \item les termes ;
   \item les formules ;
   \item les preuves.
 \end{enumerate}

 \begin{lem}[Récursion]
   Soient $p, n \in \mathds{N}$ et 
   \begin{itemize}
     \item $k_1, \ldots, k_n : \mathds{N} \to \mathds{N}$ telles que $\forall y, \forall i$, $k_i(y) < y$ ;
     \item  $g : \mathds{N}^p \to \mathds{N}$ ;
     \item $h : \mathds{N}^{p + n+1} \to \mathds{N}$
   \end{itemize}
   des fonctions récursives primitives (\textit{resp}. récursives).
   Alors, la fonction $f : \mathds{N}^{p+1} \to \mathds{N}$ définie de la façon suivante est récursive primitive (\textit{resp}. récursive primitive) :
   \[f(0, x_1, \ldots, x_p) := g(x_1, \ldots, x_p)\]
   et
   \fitbox{$f(y, x_1, \ldots, x_p) := h(y, f(k_1(y), x_1, \ldots, x_p), \ldots, f(k_n(y), x_1, \ldots, x_p), x_1, \ldots, x_p)$}.
   \qed
 \end{lem}

 \begin{lem}[Définition par cas]
   Soient $P_1, \ldots, P_n$ des ensembles récursifs primitifs (\textit{resp}. récursifs) disjoints de $\mathds{N}^m$ et $f_1, \ldots, f_{n+1}$ des fonctions récursives primitives (\textit{resp}. récursives) $\mathds{N}^m \to \mathds{N}$ alors la fonction suivante est récursive primitive (\textit{resp}. récursive) :
   \[
   f(x_1, \ldots, x_m) := \begin{cases}
     f_1(x_1, \ldots, x_m) & \text{ si } P_1(x_1, \ldots, x_m)\\
     f_2(x_1, \ldots, x_m) & \text{ si } P_2(x_1, \ldots, x_m)\\
     \quad\quad\quad\vdots \quad & \quad\quad\quad\quad \vdots\\
     f_n(x_1, \ldots, x_m) & \text{ si } P_n(x_1, \ldots, x_m)\\
     f_{n+1}(x_1, \ldots, x_m) & \text{ sinon}
   \end{cases}
   \] \qed
 \end{lem}

 \begin{lem}[Définition par cas et récursion]
   Soient $p, n, m \in \mathds{N}$, et 
   \begin{itemize}
     \item $g : \mathds{N}^p \to \mathds{N}$
     \item $k_1, \ldots, k_m : \mathds{N} \to \mathds{N}$
     \item $f_1, \ldots, f_n : \mathds{N}^{m + p + 1} \to \mathds{N}$
     \item $f_{n+1} : \mathds{N}^p \to \mathds{N}$
   \end{itemize}
   des fonctions récursives primitives (\textit{resp}. récursives) et $P_1, \ldots, P_n$ des ensembles disjoints de $\mathds{N}^p$ récursifs primitifs (\textit{resp.} récursifs) alors la fonction suivante est récursive primitive :
   \[f(0, x_1, \ldots, x_p) := g(x_1, \ldots, x_p)\]
   et 

   \fitbox{$f(y, x_1, \ldots, x_p) := \begin{cases}
     f_1(y, f(k_1(y), x_1, \ldots, x_p), \ldots, f(k_m(y), x_1, \ldots, x_p), x_1, \ldots, x_p) & \text{ si } P_1(x_1, \ldots, x_p)\\
     f_2(y, f(k_1(y), x_1, \ldots, x_p), \ldots, f(k_m(y), x_1, \ldots, x_p), x_1, \ldots, x_p) & \text{ si } P_2(x_1, \ldots, x_p)\\
     \quad\quad\quad\quad \vdots\\
     f_n(y, f(k_1(y), x_1, \ldots, x_p), \ldots, f(k_m(y), x_1, \ldots, x_p), x_1, \ldots, x_p) & \text{ si } P_n(x_1, \ldots, x_p)\\
     f_{n+1}(x_1, \ldots, x_p)
   \end{cases}$}
   \qed
 \end{lem}

 \subsection{Codage des suites d'entiers.}

 \begin{prop}
   Pour tout entier non nul $p$ il existe des fonctions récursives primitives bijectives $\alpha_p : \mathds{N}^p \to \mathds{N}$ et $\beta^1_p, \ldots, \beta_p^p : \mathds{N} \to \mathds{N}$ telles que la réciproque de $\alpha_p$ est $(\beta_p^1, \ldots, \beta_p^p)$ et, de plus, si $x > 1$ et $p \ge 2$ alors $\beta_p^i(x) < x$.
 \end{prop}
 \begin{prv}
   L'idée est qu'on utilise la fonction de Cantor (ou l'énumération de Peano) :
   \[
   \alpha_2(n, m) := \frac{(n+m)(n+m+1)}{2} + n
   \]
   et on pose \[
   \alpha_{p+1}(x_1, \ldots, x_{p+1}) := \alpha_p(x_1, \ldots, x_{p-1}, \alpha_2(x_p, x_{p+1}))
   .\]
   Ainsi, \[
   \alpha_p(x_1, \ldots, x_p) = \alpha_2(x_1, \alpha_2(x_2, \ldots))
   .\] 
 \end{prv}

 \subsection{Les termes.}
 On suppose que l'ensemble des variables est $\{x_i  \mid i \in \mathds{N}\} $.

 \begin{defn}
   Le nombre de Gödel d'un terme $t$ sur $\mathcal{L}$, noté $\sharp t$, est défini par :
   \begin{itemize}
     \item $t = \repr{0}$ alors  $\sharp t := \alpha_3(0, 0, 0)$ ;
     \item $t = x_n$ alors  $\sharp t := \alpha_3(n+1, 0, 0)$ ;
     \item $t = \succ t_1$ alors $\sharp t := \alpha_3(\sharp t_1, 0, 1)$ ;
     \item $t = t_1 \oplus t_2$ alors $\sharp t := \alpha_3(\sharp t_1, \sharp t_2, 2)$ ;
     \item $t = t_1 \otimes t_2$ alors $\sharp t := \alpha_3(\sharp t_1, \sharp t_2, 3)$.
   \end{itemize}
 \end{defn}

 \begin{lem}
   Le codage est injectif.
 \end{lem}
 \begin{prv}
   Expliciter la fonction de décodage définie sur l'espace image.
 \end{prv}

 \begin{lem}
   L'ensemble $\mathrm{Term} := \{\sharp t  \mid \text{$t$ est un terme de $\mathcal{L}_0$}\}$ est récursif primitif.
 \end{lem}

 \begin{prv}
   Montrons que la fonction caractéristique $T$ de $\mathrm{Term}$ est récursif primitif.
   On utilise le lemme de définition par cas et récursion donné précédemment :
   \begin{itemize}
     \item si $\beta_3^3(x) = 0$ et  $\beta_3^2(x) = 0$ alors  $T(x) = 1$ ($x$ est le code de $\repr{0}$ ou  $x_{\beta_3^1(x) - 1}$) ;
     \item si $\beta_3^3(x) = 1$ et  $\beta_3^2(x) = 0$ alors  $T(x) = T(\beta_3^1(x))$ ($x$ est le code de $\succ t$) ;
     \item si $\beta_3^3(x) = 2$ alors  $T(x) = T(\beta_3^1(x)) \cdot T(\beta_3^2(x))$ ($x$ est le code de $t \oplus t$) ;
     \item si $\beta_3^3(x) = 3$ alors  $T(x) = T(\beta_3^1(x)) \cdot T(\beta_3^2(x))$ ($x$ est le code de $t \otimes t$) ;
     \item sinon, $T(x) = 0$.
   \end{itemize}
 \end{prv}

 \subsection{Les formules.}
 \begin{defn}
   On étend $\sharp \cdot $ aux formules :
   \begin{itemize}
     \item $\sharp (t_1 = t_2) := \alpha_3(\sharp t_1, \sharp t_2, 0)$
     \item $\sharp (\lnot F) := \alpha_3(\sharp F, 0, 1)$
     \item $\sharp (F_1 \lor F_2) := \alpha_3(\sharp F_1, \sharp F_2, 2)$
     \item $\sharp (F_1 \land F_2) := \alpha_3(\sharp F_1, \sharp F_2, 3)$
     \item $\sharp (F_1 \to F_2) := \alpha_3(\sharp F_1, \sharp F_2, 4)$
     \item $\sharp (\forall x_k \: F) := \alpha_3(\sharp F, k, 5)$
     \item $\sharp (\exists  x_k \: F) := \alpha_3(\sharp F, k, 6)$
     \item $\sharp \bot  = \alpha_3(0, 0, 7)$.
   \end{itemize}
 \end{defn}

 \begin{lem}
   Le codage ci-dessus est injectif.
   \qed
 \end{lem}

 \begin{lem}
   L'ensemble $\mathrm{Form} := \{\sharp F  \mid F \text{ formule de } \mathcal{L}_0\} $ est récursif primitif.
   \qed
 \end{lem}

 \subsection{Opérations sur les formules.}

 \begin{lem}
   Les ensembles suivants sont récursifs primitifs :
   \footnotesize
   \begin{itemize}
     \item $\theta_0 := \{(\sharp t, n)  \mid \text{$t$ est un terme et $x_n$ n'a pas d'occurrence dans $t$}\}$
     \item $\theta_1 := \{(\sharp t, n)  \mid \text{$t$ est un terme et $x_n$ a une occurrence dans $t$}\}$
     \item $\phi_0 := \{(\sharp F, n)  \mid \text{$F$ est une formule et $x_n$ n'a pas d'occurrence dans $F$}\} $
     \item $\phi_1 := \{(\sharp F, n)  \mid \text{$F$ est une formule et $x_n$ n'a pas d'occurrence libre dans $F$}\} $
     \item $\phi_2 := \{(\sharp F, n)  \mid \text{$F$ est une formule et $x_n$ n'a pas d'occurrence liée dans $F$}\} $
     \item $\phi_3 := \{(\sharp F, n)  \mid \text{$F$ est une formule et $x_n$ a une occurrence libre dans $F$}\} $
     \item $\phi_4 := \{(\sharp F, n)  \mid \text{$F$ est une formule et $x_n$ a une occurrence liée dans $F$}\} $
     \item $\phi_5 := \{\sharp F  \mid \text{ $F$ est une formule close }\} $
   \end{itemize}
 \end{lem}
 \begin{prv}
   On montre le résultat pour $\theta_0$ (le reste en exercice).
   On définit la fonction caractéristique de $\theta_0$, notée  $g_0(x, y)$, par (en utilisant le lemme de définition par cas et récursion) :
    \begin{itemize}
     \item si $\beta_3^3(x) = \beta_3^2(x) = 0$ et  $\beta_3^1(x) - 1 \neq y$ alors $g_0(x, y) := 1$ ;
     \item si $\beta_3^2(x) = 1$ et $\beta_3^2(x) = 0$ alors  $g_0(x,y) := g_0(\beta_3^2(x), y)$ ;
     \item si  $\beta_3^3(x) = 2\text{ ou } 3$ alors $g_0(x,y) := g_0(\beta_3^1(x), y) \times g_0(\beta_3^2(x), y)$ ;
     \item sinon, $g_0(x,y) := 0$.
   \end{itemize}
 \end{prv}

 \begin{lem}[Substitutions]
   Il existe des fonctions récursives primitives $\mathrm{Subst_t}$ et $\mathrm{Subst_f}$ à trois variables telles que, si $t$ t $u$ sont des termes, et si $G$ est une formule, alors pour tout entier $n$, 
   \begin{itemize}
     \item $\mathrm{Subst_t}(n, \sharp t, \sharp u) := \sharp (u[x_n := t])$
     \item $\mathrm{Subst_f}(n, \sharp t, \sharp F) := \sharp (F[x_n := t])$.
   \end{itemize}
 \end{lem}
 \begin{prv}
   On définit $\mathrm{Subst_t}$ par cas/récursion. Pour $(n, y, x)$, on a  :
   \begin{itemize}
     \item si $\beta_3^3(x) = 0$  alors
       \begin{itemize}
         \item si $\beta_3^1(x) = n+1$ alors  $\mathrm{Subst_t}(n, y, x) := y$,
         \item sinon $\mathrm{Subst_t}(n, y, x) := x$ ;
       \end{itemize}
     \item si $\beta_3^3(x) = 1$ alors $\mathrm{Subst_t}(n, y, x) := \alpha_3(\mathrm{Subst_t}(n, y, \beta_3^1(x)), 0, 1)$ ;
     \item si $\beta_3^3(x) = 1$ alors\\ {\small $\mathrm{Subst_t}(n, y, x) := \alpha_3(\mathrm{Subst_t}(n, y, \beta_3^1(x)), \mathrm{Subst_t}(n, y, \beta_3^2(x)), \beta_3^3(x))$}~;
     \item sinon $\mathrm{Subst_t}(n, y, x) := 0$.
   \end{itemize}

   Puis, on définit $\mathrm{Subst_f}$ par :
   \tiny
   \begin{itemize}
     \item si $\beta_3^3(x) = 0$ alors $\mathrm{Subst_f}(n, y, x) = \alpha_3(\mathrm{Subst_t}(n, y, \beta_3^1(x))), \mathrm{Subst_t}(n, y, \beta_3^1(x), 0)$ ;
     \item si $\beta_3^3(x) = 1$ alors $\mathrm{Subst_f}(n, y, x) = \alpha_3(\mathrm{Subst_f}(n, y, \beta_3^1(x)), 0, 1)$ ;
     \item si $\beta_3^3(x) = 2, 3, \text{ ou } 4$ alors $\mathrm{Subst_f}(n, y, x) = \alpha_3(\mathrm{Subst_f}(n, y, \beta_3^1(x)), \mathrm{Subst_f}(n, y, \beta_3^2(x)), \beta_3^3(x))$ ;
     \item si $\beta_3^3(x) = 5 \text{ ou } 6$ alors
       \begin{itemize}
         \item si $\beta_3^2(x) = n$ et $x_n$ est liée dans $F$ donc $\mathrm{Subst_f}(n, y, x) := x$ ;
         \item sinon donc $\mathrm{Subst_f}(n, y, x) := \alpha_3(\mathrm{Subst_f}(n, y, \beta_3^1(x)), \beta_3^2(x), \beta_3^3(x))$ ;
       \end{itemize}
     \item si $\beta_3^3(x) = 7$ alors  $\mathrm{Subst_f}(n, x, y) := x$ ;
     \item sinon, $\mathrm{Subst_f}(n, x, y) := 0$.
   \end{itemize}
 \end{prv}

 \subsection{Codage des preuves.}

 On code un contexte comme des suites finies, \textit{i.e.} des listes, de formules (c'est plus facile que pour les ensembles).
 \begin{defn}
   On définit le codage par :
   \begin{itemize}
     \item $\sharp \texttt{[\:]} := 0$ ;
     \item $\sharp (F \mathop{\texttt{::}} \Gamma) := 1 + \alpha_2(\sharp \Gamma, \sharp F)$.
   \end{itemize}
 \end{defn}

 \begin{lem} Le décodage est unique. \qed \end{lem}
 \begin{lem}
   La substitution d'une formule dans un contexte est récursif primitif.
   Tester si une variable est libre (\textit{resp.} liée) dans un contexte est récursif primitif.
   \qed
 \end{lem}

 \subsection{Codage des preuves en déduction naturelle.}

 \begin{rmk}
   Le contexte de la conclusion et des prémisses est le même sauf pour 
   \[
   \begin{prooftree}
     \hypo{\Gamma \vdash A}
     \infer 1[\mathsf{aff}]{\Gamma, B \vdash A}
   \end{prooftree}
   \quad
   \begin{prooftree}
     \hypo{\Gamma, A \vdash B}
     \infer 1[\to_\mathsf{i}]{\Gamma \vdash A \to B}
   \end{prooftree}
   \quad
   \begin{prooftree}
     \hypo{\Gamma, A \vdash \bot}
     \infer 1[\to_\mathsf{i}]{\Gamma \vdash \lnot A}
   \end{prooftree}
   \] 
   \[
   \begin{prooftree}
     \hypo{\Gamma, \lnot A \vdash \bot}
     \infer 1[\bot_\mathsf{c}]{\Gamma \vdash A}
   \end{prooftree}
   \quad
   \begin{prooftree}
     \infer 0[\mathsf{ax}]{\Gamma \vdash A}
   \end{prooftree}
   .\]

   On peut toujours déterminer le contexte du haut à partir du bas donc donner le contexte de la racine suffit.
   Une preuve est donc finalement un contexte et un arbre de dérivation où les nœuds sont étiquetés par une formule et un numéro de règle.
 \end{rmk}

 \begin{exm}
   La preuve 

   \fitbox{
    $\begin{prooftree}
     \infer 0[\mathsf{ax}]{\lnot A, A \vdash A}
     \infer 0[\mathsf{ax}]{\lnot A, A \vdash \lnot A}
     \infer 2[\lnot_\mathsf{e}]{\lnot A, A \vdash \bot}
     \infer 1[\to_\mathsf{i}]{\lnot A \vdash A \to \bot}
     \infer 1[\to_\mathsf{i}]{ \vdash \lnot A \to (A \to \bot)}
     \infer 0[\mathsf{ax}]{A \to \bot, A \vdash A}
     \infer 0[\mathsf{ax}]{A \to \bot, A \vdash A \to \bot}
     \infer 2[\to_\mathsf{e}]{A \to \bot, A \vdash \bot}
     \infer 1[\lnot_\mathsf{i}]{A \to \bot  \vdash  \lnot A}
     \infer 1[\to_\mathsf{i}]{\vdash (A \to \bot) \to \lnot A}
     \infer 2[\land_\mathsf{i}]{\vdash \lnot A \leftrightarrow (A \to \bot)}
   \end{prooftree}$
   }

   peut être codée par l'arbre suivant avec le contexte $\texttt{[\:]}$ à la racine :
   \begin{figure}[H]
     \centering
     \begin{tikzpicture}[sibling distance=4cm, level distance=15mm]
       \node[rounded rectangle, draw] {$6, \lnot A \leftrightarrow (A \to \bot)$} [grow'=up]
       child {
        node[rounded rectangle, draw] {$4, \lnot A \to (A \to \bot)$}
        child {
          node[rounded rectangle, draw] {$4, A \to \bot$}
          child[sibling distance=2cm] {
            node[rounded rectangle, draw] { $1, \bot$ }
            child { node[rounded rectangle, draw] {$0, A$} }
            child { node[rounded rectangle, draw] {$0, \lnot A$} }
          }
        }
       }
       child {
        node[rounded rectangle, draw] {$4, (A \to \bot) \to \bot A$}
        child {
          node[rounded rectangle, draw] {$2, \lnot A$}
          child[sibling distance=2cm] {
            node[rounded rectangle, draw] { $3, \bot$ }
            child { node[rounded rectangle, draw] {$0, A$} }
            child { node[rounded rectangle, draw] {$0, A \to \bot$} }
          }
        }
       }
       ;
     \end{tikzpicture}
   \end{figure}
 \end{exm}

 \begin{defn}
   On numérote 
   \begin{itemize}
     \item $\sharp \mathsf{ax} := 0$
     \item $\sharp \lnot_\mathsf{e} := 1$
     \item $\sharp \lnot_\mathsf{i} := 2$
     \item $\sharp \to_\mathsf{e} := 3$
     \item $\sharp \to_\mathsf{i} := 4$
     \item $\sharp \land_\mathsf{e} := 5$
     \item $\sharp \land_\mathsf{i} := 6$
     \item \textit{etc}.
   \end{itemize}
 \end{defn}

 \begin{defn}[Nombre de Gödel des preuves]
   \begin{itemize}
     \item Si $D^\star$ est un arbre de preuve à un seul nœud étiqueté par la formule  $F$ et la règle $n$ alors $\sharp D^\star := \alpha_3(n, \sharp F, 0)$.
     \item Si $D^\star$ est un arbre de preuve dont la racine est étiquetée par la formule  $F$ et la règle $n$ à $k$ prémisses avec les sous arbres $D_1^\star, \ldots, D_k^\star$ 
       \[
       \begin{prooftree}
         \hypo{D_1^\star} \hypo{\cdots} \hypo{D_k^\star}
         \infer 3[\text{règle $n$}]{F}
       \end{prooftree}
       \]
       alors $\sharp D^\star := \alpha_3(n, \sharp F, \alpha_k(\sharp D_1^\star, \ldots, \sharp D_k^\star) + 1)$.
   \end{itemize}

   On pose ensuite $\sharp D := \alpha_2(\sharp D^\star, \sharp \Gamma)$ pour une preuve $D$.
 \end{defn}

 \begin{lem}
   C'est un code injectif.
 \end{lem}
 \begin{lem}
   L'ensemble $\mathrm{Preuve} := \{\sharp D  \mid D \text{ est une preuve}\}$ est récursif primitif.
 \end{lem}

 \subsection{Qu'est ce qu'une bonne théorie ?}

 \begin{defn}
   Un ensemble $A$ de formules est un ensemble d'\textit{axiomes} de la théorie $T$ si $A \vdash T$ et $T \vdash A$.
 \end{defn}

 \begin{defn}
   Une théorie $T$ sur $\mathcal{L}_0$ a un ensemble d'axiomes $\mathrm{Ax}_T$ récursif si l'ensemble des numéros de formules de $\mathrm{Ax}_T$ est récursif.
 \end{defn}
 \begin{rmk}
   Si $\mathrm{Ax}_T$ est fini, alors il est récursif (exemple : $\mathcal{P}_0$).
 \end{rmk}

 \begin{lem}
   L'ensemble des axiomes de Peano $\mathcal{P}$ est récursif.
 \end{lem}
 \begin{prv}
   Il suffit de montrer que l'ensemble des axiomes du schéma de récurrence est récursif.
   On définit

 \fitbox{$A_F := \forall x_1 \: \cdots \: \forall x_n \Big(\big(F(0, x_1, \ldots, x_n) \land \forall x_0 \: (F(x_0, \ldots, x_n) \to F(\succ x_0, x_1, \ldots, x_n))\big) \to \forall x_0 \: F(x_0, \ldots, x_n) \big)\Big)$.}

  Idée pour décider si $N$ est le code d'une formule $A_F$ : 
  \begin{enumerate}
    \item décoder pour trouver $n$ et $F$ ;
    \item calculer $\sharp A_F$ et vérifier si c'est $N$.
  \end{enumerate}
 \end{prv}
\end{document}
